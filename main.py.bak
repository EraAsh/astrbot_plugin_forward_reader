import json
from typing import List, Dict, Any, Optional

from astrbot.api import logger, AstrBotConfig
from astrbot.api.event import filter, AstrMessageEvent
from astrbot.api.star import Context, Star, register
import astrbot.api.message_components as Comp

# 检查是否为 aiocqhttp 平台，因为合并转发是其特性
try:
    from astrbot.core.platform.sources.aiocqhttp.aiocqhttp_message_event import AiocqhttpMessageEvent
    IS_AIOCQHTTP = True
except ImportError:
    IS_AIOCQHTTP = False


@register("forward_reader", "EraAsh", "一个使用 LLM 分析合并转发消息内容的插件", "1.0.8", "https://github.com/EraAsh/astrbot_plugin_forward_reader")
class ForwardReader(Star):
    def __init__(self, context: Context, config: AstrBotConfig):
        super().__init__(context)
        self.config = config
        self._load_config()

    def _load_config(self):
        """加载配置"""
        self.enable_direct_analysis = self.config.get("enable_direct_analysis", False)
        self.enable_reply_analysis = self.config.get("enable_reply_analysis", True)
        self.system_prompt = self.config.get(
            "system_prompt",
            "你是一个专业的聊天记录分析助手。你的任务是根据用户提供的聊天记录（可能包含文字和图片）和用户的提问，进行总结和回答。如果用户没有明确提问，请对聊天记录进行一个全面的摘要。聊天记录的格式为 '发送者: 内容'。"
        )

    @filter.event_message_type(filter.EventMessageType.ALL)
    async def on_any_message(self, event: AstrMessageEvent, *args, **kwargs):
        """
        通过将合并转发的内容注入原始消息，实现上下文感知的LLM分析。
        这确保了分析结果能被AstrBot的记忆系统正确记录。
        """
        self._load_config()

        if not (IS_AIOCQHTTP and isinstance(event, AiocqhttpMessageEvent) and self.enable_reply_analysis):
            return

        # 核心逻辑：仅当用户回复消息时触发
        reply_seg = next((seg for seg in event.message_obj.message if isinstance(seg, Comp.Reply)), None)
        if not reply_seg:
            return

        try:
            client = event.bot
            original_msg = await client.api.call_action('get_msg', message_id=reply_seg.id)

            # 确认被回复的消息是合并转发
            if not (original_msg and 'message' in original_msg and isinstance(original_msg['message'], list)):
                return
            
            forward_seg_data = None
            for segment in original_msg['message']:
                if segment.get("type") == "forward":
                    forward_seg_data = segment.get("data", {})
                    break
            
            if not forward_seg_data:
                return

            # 获取转发消息的完整数据
            forward_data = None
            if 'messages' in forward_seg_data: # 兼容Lagrange等客户端的内联数据
                logger.info("检测到内联合并转发数据，直接使用。")
                forward_data = forward_seg_data
            elif 'id' in forward_seg_data:
                try:
                    logger.info(f"尝试通过ID {forward_seg_data['id']} 获取合并转发数据。")
                    forward_data = await client.api.call_action('get_forward_msg', id=forward_seg_data['id'])
                except Exception as e:
                    logger.error(f"通过ID获取合并转发内容失败: {e}")
                    # 此处失败后不中断，允许机器人用默认方式回复
                    return
            
            if not (forward_data and 'messages' in forward_data):
                logger.warning("无法获取有效的合并转发内容。")
                return

            # --- 上下文注入核心逻辑 ---
            user_query = event.message_str.strip() if event.message_str.strip() else "请对聊天记录进行摘要。"
            
            # 1. 提取文本和图片
            extracted_texts, image_urls = self._extract_forward_content(forward_data)
            if not extracted_texts and not image_urls:
                return # 没有可分析内容，退出

            # 2. 构建新的、包含完整上下文的提示词
            enhanced_prompt = (
                f"请基于以下聊天记录和图片，回答我的问题。\n"
                f"我的问题是：{user_query}\n\n"
                f"--- 聊天记录开始 ---\n"
                f"{'\n'.join(extracted_texts)}\n"
                f"--- 聊天记录结束 ---"
            )

            # 3. 重构事件（Event）对象，注入新上下文
            logger.info("ForwardReader: 重构消息事件以注入合并转发的上下文。")
            event.message_str = enhanced_prompt
            
            new_chain = [Comp.Plain(enhanced_prompt)]
            # 将图片也加入到消息链中，以便主LLM处理器能够看到
            for url in image_urls:
                new_chain.append(Comp.Image.fromURL(url))
            event.message_obj.message = new_chain
            event.message_obj.raw_message = enhanced_prompt # 更新原始消息文本

            # 4. 移除回复组件，避免主处理器困惑
            event.message_obj.message = [seg for seg in event.message_obj.message if not isinstance(seg, Comp.Reply)]

            # 5. 放行事件，让AstrBot的核心处理器接管
            logger.info("ForwardReader: 上下文注入完成，事件将继续传递。")
            # 注意：此处不再调用 event.stop_event()

        except Exception as e:
            logger.error(f"ForwardReader在处理过程中发生意外错误: {e}")
            # 发生错误时，不应中断正常的消息流
            return

    def _extract_forward_content(self, forward_data: dict) -> (List[str], List[str]):
        """从转发数据中提取文本和图片URL"""
        extracted_texts = []
        image_urls = []
        for message_node in forward_data.get("messages", []):
            sender_name = message_node.get("sender", {}).get("nickname", "未知用户")
            content_chain = message_node.get("content", [])

            node_text_parts = []
            if isinstance(content_chain, str):
                node_text_parts.append(content_chain)
            elif isinstance(content_chain, list):
                for segment in content_chain:
                    if isinstance(segment, dict):
                        seg_type = segment.get("type")
                        if seg_type == "text":
                            node_text_parts.append(segment.get("data", {}).get("text", ""))
                        elif seg_type == "image":
                            url = segment.get("data", {}).get("url")
                            if url:
                                image_urls.append(url)
                                node_text_parts.append("[图片]")
            
            full_node_text = "".join(filter(None, node_text_parts)).strip()
            if full_node_text:
                extracted_texts.append(f"{sender_name}: {full_node_text}")
        return extracted_texts, image_urls

    async def terminate(self):
        pass
